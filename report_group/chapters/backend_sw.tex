\chapter{Backend Software}
------------------------

\section{Overview}
  In order to store and show the results sent from the {\bf FPGA} in a database a web server was developed; this server provides the user an interface where they can 
see and manage the results, upload designs and configuration files to the {\bf chip tester} and administrate the database where the results have been stored. Basically
the web server ``serves'' the content to the user through the Internet to a web page, where the users (administrators or students) can check the results of their designs
or manage the results stored in the database. The users load their designs into the web server and then whenever the FPGA sends a ``download configuration files request''
to the server, it sends the files to the FPGA (if available), also the server provides the {\bf FPGA} the methods for storing in the database all the results obtained after
a test has been done.

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.4]{back_end_overview.png}
\caption{Interaction between elements in the system}
\label{fig:back_end_structure}
\end{figure}


 Nowadays almost every programming language provides libraries to develop web servers; for this application we required a robust, easy to use, programming language. Java, Python, PhP, Ruby,
Perl are the most common languages used to develop servers. We decided to use Ruby with its{\bf web framework} Sinatra because Ruby is a general-purpose object-oriented programming language easy to learn
and powerful, Sinatra is a Domain Specific Language (DSL) for quickly creating web applications in ruby. 

WEBrick is an HTTP server built as part of Ruby 1.8 and it is the default HTTP server when
developing an application in ruby, not to mention the core of the application itself, nevertheless, WEBbrick has a major drawback: It does a reverse DNS lookup for every incoming HTTP request on 
the IP address that makes the request. This means that if the FPGA has no entry for a reverse DNS the server has to wait until the lookup times out (the default timeout in WEBbrick is 5 seconds). 
This feature can be ``easily'' changed modifying some native code in the WEBbrick library, nevertheless, it has to be changed whenever the environment is set up again. The solution to this problem is to
use Unicorn, Unicorn is an HTTP server that has been designed to be fast and easily configurable, therefore it has the reverse DNS lookup disabled by default and performs the calls from the FPGA in milliseconds.  

\section{Server}

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.5]{server_structure.png}
\caption{Folder structure of the server}
\label{fig:server_structure}
\end{figure}

  Inside the folder called {\bf server} are all the files regarding to our back-end application. In the folder {\bf public} are the stylesheets for the web page styling, and the images 
displayed in the page, in {\bf uploads} are all the files uploaded in the server by the users, in {\bf utils} are some utility scripts written in ruby such as secure password generation,
{\bf views} contains all the views in the page that the different users can have access to and in the folder {\bf adc\_data} are all the measurements taken by the adc in the tester and uploaded 
on the server by the FPGA.

\subsection{Database}

  Datamapper is an ORM (Object-Relational Mapping) that maps objects written in ruby to any supported database, thus giving freedom to the administrators of the system to use any database system (such as 
MySQL, SQLite, Postgres,\ldots) to choose the database the administrator simply has to change the configuration parameters in the file {\bf config.yml} (found in the server folder) as shown in the 
figure \ref{fig:database_config} where the administrator has set up the database system with MySql.

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.6]{database_config.png}
\caption{Database system selection using the config.yml file}
\label{fig:database_config}
\end{figure}

The figure shows an example of the class Admin written in ruby, this class is mapped into the database by datamapper (the fields created by the ORM in the database are shown in the table \ref{tab:admin_table}.
\begin{figure}[htb]
\centering
\includegraphics[scale = 0.8]{orm_admin.png}
\caption{Class admin that will be mapped by the ORM (Datamapper) into the database}
\label{fig:admin_orm}
\end{figure}

The Tables in the database are presented below. In the table Admin \ref{tab:admin_table} are stored the administrators of the database. The email field is the email used to log in,
the Permission field is the level of authority that each administrator has. It can be either 0 or 1 (where 0 means that it can add
more administrators to the system and 1 means that can only manage the database) and the password\_hash field is a hash related to the user password (more in the server security section)

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l |}
    \hline
    Email & Permission & Password\_hash  \\ \hline
    String & Integer & BCryptHash \\ \hline
    \end{tabular}
    \caption{Admin table in the database}
    \label{tab:admin_table}
\end{table}

The initial administrator and master Administrator is configured in the archive config.yml as shown in the figure \ref{fig:admin_config}. For security reasons the password of 
the initial administrator must be encrypted using the script {\bf pass.rb} located in server/utils. Whenever the server is run by the first time, or the database
has been created again this user will be mapped into the database, granting always access to the administrator. 

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.75]{master_admin.png}
\caption{Initial Master Admin selection using the config.yml file}
\label{fig:admin_config}
\end{figure}

The File Upload table \ref{tab:file_upload_table} in the database stores the configuration files that has been uploaded to the server by the students, the file name is a hash of the contents of the uploaded file,
this is to prevent students from uploading the same design.

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    Id & Email & Team & File\_name & Is\_valid & Created\_at & Updated\_at  \\ \hline
    Serial & String & Integer & String & Boolean & Date & Date \\ \hline
    \end{tabular}
    \caption{File Upload table in the database}
    \label{tab:file_upload_table}
\end{table}

The Log entry table \ref{tab:log_entry_table} stores all the logs sent from the FPGA to the server, this table is displayed to the user in the web page. The type of messages that can be stored are ``Debug'', ``Info'', ``Warning'' and ``Error'',
if there has been an error in the vector file uploaded to test the results, the line where the error was found is stored, giving information to the students about their mistake.

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    Id & Type & Message & File & Line & Created\_at & Updated\_at  \\ \hline
    Serial & Integer & String & String & Integer & Date & Date \\ \hline
    \end{tabular}
    \caption{Log Entry table in the database}
    \label{tab:log_entry_table}
\end{table}

The result table \ref{tab:Result_table} has an overview of the design uploaded into the FPGA. This table is displayed to the user in the overview view. 

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l | l | l | l | l | l |}
    \hline
    Id & Team & Academic Year & Email & Created\_at & Updated\_at & Virtual & Email sent \\ \hline
    Serial & Integer & String & String & Date & Date & Boolean & Boolean\\ \hline
    \end{tabular}
    \caption{Result table in the database}
    \label{tab:Result_table}
\end{table}

The table Design Results \ref{tab:design_result_table} belongs to the Results table and it has specific information related to the test done in the design.

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    Id & Created\_at & Updated\_at & Triggers & File\_name & Clock\_Frequency & Design\_name  \\ \hline
    Id & Date & Date & String & String & String & String \\ \hline
    \end{tabular}
    \caption{Design Result table in the database}
    \label{tab:design_result_table}
\end{table}

The table Test Vector Result \ref{tab:Test_vector_result_table} belongs to the table Design Result and it has more detailed information (for example the expected inputs vectors and the obtained results) inherent to the design tested on the FPGA. 

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l | l | l | l | }
    \hline
    Id & Type & Input\_vector & Expected\_result & Actual\_result & Cycle\_count\\ \hline
    Serial & Integer & String & String & String & Integer \\ \hline
    \end{tabular}
\end{table}

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | l | l | l | l |}
	\hline
       Trigger\_timeout & Has\_run & Fail & Created\_at & Updated\_at\\ \hline
       Boolean & Boolean & Boolean & Date & Date\\ \hline
    \end{tabular}
    \caption{Test Vector Result table in the database}
    \label{tab:Test_vector_result_table}
\end{table}

The Frequency Measurement table \ref{tab:Frequency_measurement_table} belongs to the Design result table and has data related to the measurement of the frequency of the digital
oscillator on the chip. The frequency field is a float with the value of the measured frequency and the pin field is the defined pin used to measure the frequency. 

\begin{table}[h!]
\centering
    \begin{tabular}{| l | l | l | l | l |}
	\hline
       Id & Frequency & Pin & Created\_at & Updated\_at\\ \hline
       Serial & Float & String & Date & Date\\ \hline
    \end{tabular}
    \caption{Frequency Measurement table in the database}
    \label{tab:Frequency_measurement_table}
\end{table}

The ADC Measurement table \ref{tab:ADC_measurement_table} belongs to the Design result table and has data related to the sampling of the digital signal coming from the digital oscillator 
on the chip.

\begin{table}[h!]
\centering
    \begin{tabular}{| l | l | l | l |}
	\hline
       Id & Created at & Updated at \\ \hline
       Serial & Date & Date\\ \hline
    \end{tabular}
    \caption{ADC Measurement table in the database}
    \label{tab:ADC_measurement_table}
\end{table}


\section{API}

The way the FPGA communicates to the server is through the Hypertext Transfer Protocol (HTTP). In the client-server model HTTP works as a request-response protocol. The FPGA and the user web browser act as clients, while the application running 
on the computer hosting the web site is the server. The FPGA and web browser submit HTTP request messages to the server. The server stores content, provides resources such as configuration files, sends emails, manages the database on behalf of the clients. 
HTTP defines 9 methods indicating the action to be performed on a resource: HEAD, GET, POST, PUT, DELETE, TRACE, OPTION, CONNECT and PATCH. To develop this application we have used only three of this methods {\bf GET} which retrieves information from the server, 
{\bf POST} which sends data to the server as part of the request and {\bf DELETE} which deletes resources. The figure \ref{fig:get_example} shows an example of the get method, both in the server and in the browser.

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.6]{get.png}
\caption{Example of the HTTP method GET in the browser and in the server}
\label{fig:get_example}
\end{figure}

In order to communicate from the FPGA to the server a data exchange language is needed; the most popular data exchange language is ``XML'', nevertheless, adding the xml parsing libraries in the $\mu$Clinux
would slow down the parsing data process due to the complexity of the xml libraries. JSON, is a lightweight data exchange library supported in C (for the FPGA) and ruby (for the Server) therefore it was perfect 
for our application. The figure \ref{fig:Json_message} shows an example of a message in the JSON format that would be sent from the FPGA to the server.

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.6]{json_example.png}
\caption{Example of a JSON message}
\label{fig:Json_message}
\end{figure}

The table \ref{tab:api_server_fpga} shows the ``URL'' the FPGA uses to connect to the server, and a brief description of what each command does in the server. :result\_id, :design\_id,
and :name are parameters attached in the ``URL'' that ruby uses as information. 

\begin{table}[h!]
\centering
    \begin{tabular}{ | l | p{7cm} | p{5cm}|}
    \hline
    Type & Link & Command   \\ \hline
    post & /api/result & Stores the results sent from the fpga in the table Results in the database\\ \hline
    post & /api/result/:result\_id/design & Stores in the table Design\_Results associated to the result (in the table Results) identified with the id: result\_id (results summarized)\\ \hline
    post & /api/result/:result\_id/design/:design\_id	/measurement/frequency & Stores in the table FrequencyMeasurement associated to the design\_result identified with the id design\_id (information related to the frequency of the oscillator in the design)\\ \hline
    post & /api/result/:result\_id/design/:design\_id	/measurement/adc & Stores in the table AdcMeasurement associated to the design\_result identified with the id design\_id (information related to the sampled oscillator in the design)  \\ \hline
    post & /api/result/:result\_id/design/:design\_id	/vector & Stores in the table Test\_vector associated to the design\_result identified with the id design\_id (more information about the results of the test)\\ \hline
    post & /api/done/:result\_id & It sends the email to the students when everything is done\\ \hline
    get & /api/vdesign & Download a configuration file into the fpga\\ \hline
    delete & /api/received/:name & Informs the Server that the file has been received properly and can be erased.\\ \hline
    \end{tabular}
    \caption{API for the communication between the FPGA and the server}
    \label{tab:api_server_fpga}
\end{table}

\subsection{Security}

Whenever in an application is stored any user password security must be added. For instance a user could have the same password for our application than for their email, thus, if an attacker gains control over our database and the passwords are unprotected the consequences would be
terrible. The solution to harden the security in the application is to create a digital ``fingerprint'' or hash of the password and store it in the database because this process is not reversible (in other words you cannot go back from hash to password). 
Ruby offers a library to manage secure passwords storage called BCrypt, usually hashing algorithms are designed to be quick, therefore, attackers can generate more possible passwords in less time (as computing power increases more and more). Nevertheless, Bcrypt has been designed to 
be computational costly. 

The figure \ref{fig:initial_pass} shows the use of the script found in the folder {\bf /utils} ``pass.rb'' to encrypt the initial passsword of the database. As can be seen the two encrypted passwords are different, this is because everytime Bcrypts encrypts a password adds some random data 
(called salts) wich increase the protection of the password against attackers. Also note that both encrypted passwords start with ``\$2a\$10\$...'' where ``2a'' is the version of the hashing algorithm used to create the hash and ``10'' is the cost factor used to generate the password. This cost factor
was designed to cope with ``Moore's Law'' due to the fact that computers get faster and faster so an atacker can attempt to decipher the password in less time with more powerful hardware. So, increasing the cost factor also increases the time the hash takes to generate,   

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.6]{encrypted_pass.png}
\caption{Encryption of the initial admin password}
\label{fig:initial_pass}
\end{figure}


\section{E-Mails}

Once the FPGA has finished testing the chip and sent the results to the server, it sends a request to the server to send the results by email. The configuration of the mail account is shown in the figure \ref{fig:email_server}

\begin{figure}[htb]
\centering
\includegraphics[scale = 0.6]{email_config.png}
\caption{Configuration for sending out emails from the server}
\label{fig:email_server}
\end{figure}

This configuration can be adapted to any email account. In the folder {\bf views} is a file called ``email\_body.erb''. This file has the template body of the email to be sent and it can be changed easily whenever the contents of the email must be changed.

\section{Remote Reconfiguration}
%%ASK about the format of the config files and add it here

\section{User Interface}
% Pavlos

In order to provide an interface between the Superchip Tester, the database and the user, a webpage has been set up to provide the required functionality. The website provides access to the results database, but also allows the user to upload configuration files for the device.

The design of the webpage is based on a website template found on \href{http://www.freecsstemplates.org/}{CSS Templates}, altered to provide a look and functionality suitable for interface to the chip tester.

The webpage is laid out in a user-friendly and simple manner, with a navigation bar at the top of the page through which the user can browse the pages of the chip tester interface. The four entries in the navigation bar are \textit{Overview}, \textit{Admin}, \textit{Log Entries} and \textit{Upload Files}. In the main part of the screen, the content of the current view is displayed.

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.95\textwidth]{web_if_overview}
 \caption{The ChipTester webpage showing an overview of the database.}
 \label{fig:web_if_overview}
\end{figure}

In figure \ref{fig:web_if_overview}, a screenshot of the website showing the first navigation option, \textit{Overview}. This view takes the user to an overview of the database where the superchip test results are stored. The table displays information on completed tests such as the number of the team, information regarding when the test was run and the relevant academic year and the result of the test.

Clicking on the result of an entry takes the user to a more detailed view of that specific run. In this view the user can also see the measured frequency of the oscillator of the design and the name of the design. If the design has failed the test, clicking on the failed result of the test takes the user to another view, where they can monitor the failed test in more detail. This page provides information on the failed test, to help identify the reason of the failure. In specific, the user can see information about the test run, including the input vector to the design and a comparison between the expected and the actual result.

The second option of the navigation bar, \textit{Admin} prompts the user to enter their administrator credentials and takes them to the administrator view page. From this page, an administrator can reset the database, e-mail the results to a specified e-mail address, go to a detailed view of the database or add a new administrator to the system.

\hl{more stuff about manage database}

Choosing the third option on the navigation bar, \textit{Log Entries}, \hl{take the user to yet another webpage that I can't explain what it does}.

The last option of the navigation bar, \textit{Upload Files} allows the user to upload a configuration file to the server. The user is asked to enter their e-mail and their team number and a file to upload.