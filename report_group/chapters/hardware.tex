\chapter{Hardware}
% ------------------------

\section{Hardware Overview}
% Joey (get started)

The hardware part consists of two main blocks: NIOS System on Programmable Controller and the Tester.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{hw_overview}
 \caption{Hardware Overview.}
 \label{fig:hw_overview}
\end{figure}



The \textit{NIOS SoPC} coordinates the whole system, writing the data from SD Card into the SRAM for the Tester to read the data from it; retrieving the result that the Tester writes back to the SRAM and sending the data to the backend for archiving and reviewing for the users. Its tasks include:
\begin{itemize}
 \item coordinate the data from multiple sources (SRAM, SD Card, Flash, Serial connection, SPI bus, Ethernet, etc.)
 \item control the testing process (which is executed by the Tester, frequency counter and ADC)
 \item send results to the backend
 \item user interface
\end{itemize}

The \textit{SRAM arbiter} is the interface between the SoPC, tester and the SRAM by Avalon Memory Mapped Interface (Avalon-MM). It handles the SRAM read and write requests from SoPC and tester.

The \textit{Tester} contains several HDL blocks which are responsible for the testing process.
\begin{itemize}
 \item read the command, request and test vector from SRAM
 \item generate the test input signals for every pin of the DUT
 \item monitor the output pins of the DUT and write the result into the memory when the it is valid
 \item offer a dynamically reconfigurable clock for the DUT and its relative interface
\end{itemize}

The purpose of the \textit{frequency counter} and the \textit{ADC} is that there is a designated pin on the chip which is the output of a ring oscillator. It is preferable that not only the frequency of this clock output is tested, but that the output waveform is also monitored.


\section{PCB (interface board)}
% Nano (and Joey)

For the chip tester, two PCBs are needed in this project. One which is called B2 has been designed for the virtual designs to be loaded in a slave FPGA. The other is called B1 that is developed as an interface for those real chips are about to be tested. Both PCBs are two layers board and designed by using Allegro 16.3 PCB designer tools. The dimensions of B1 and B2 are $98.93 mm* 68.5 mm$ and $81.28 mm * 68.33 mm$ and the minimum wire size is $8mm$.

\subsection{B1 (DUT testing board)}

\subsubsection{DUT}

The superchip under test has the following specific features:
\begin{itemize}
 \item $16$ separate design sites
 \item $24$ digital input pins [$A0\dots A23$], shared between all design sites;
 \item $24$ digital output pins [$Q0\dots Q23$], shared between all design sites;
 \item $16$ separate VDD pins, one dedicated to each design site;
 \item $1$ global GND pin for all design sites and infrastructure circuitry;
 \item $1$ global VDD pin to power the site buffers and I/O pad ring;
 \item $68$-pin JLCC package (with 2 unused pins).
\end{itemize}

The chip is interfaced with the PCB by a 68WAY PLCC socket. The power is supplied by the $3.3V$ VDD from the DE2 board. The GND is also connected to the DE2 GND.

The shared I/Os are connected to the powered design site, and disconnected from the other design sites. Hence a controllable power switch is designed with a $4-16$ decoder and an integrated power switch array. The Q1 is the output of a ring oscillator. The frequency can be digitally tested by the general I/O. However, to examine the analog properties of this output, an analog part including a buffer, $3^{rd}$ order Butterworth filter and ADC with their own power supply is also designed.


\subsubsection{Digital Part}

\paragraph{Decoder}

Although there are 16 design sites to be selected, the data can be shrunk down to $4$ bits to save space of the test vector and metadata, since only one site is selected at a time. The decoder we used is $74HC4514$, a $4-to-16$ line decoder with latch. The input and output are active high.

\paragraph{Switch Array}

The switch array consists of four $TPS2095$ quad power-distribution switches. One could simply use a CMOS to realize a switch. However, with thermal sense, current limit and charge pump, the $TPS2095$ switches are more reliable, stable, smooth (minimum switching current surges) and relatively compact in scale. The operation of a switch is simple: when EN pin is asserted, the OUT pin offers the power with the same voltage in the IN pin. Otherwise the OUT pin is disconnected from the input power. In one $TPS2095$ chip there are 4 such switches, the EN pins of which are all active high.


\subsubsection{Analog Part}

\begin{figure}
 \centering
 \includegraphics[width=0.95\textwidth]{analog_1}
 \caption{Analog Part Overview.}
 \label{fig:analog_overview}
\end{figure}

\paragraph{Buffer}
An $AD8139$ differential ADC driver is used as the front buffer of the ADC. It is an ultralow noise, high performance differential amplifier with rail to rail output from Analog Devices. The designed gain of the buffer is $0.295$, and the differential gain is approximately $0.14$.

\paragraph{ADC}
The $8-bit$, $100MSPS$ ADC is used to convert the analog signal. The encode clock is the clock from the DE2 board ($100MHz$ by default). A power-down function select is also connected to the FPGA for shutting down the ADC when it’s not in use. The ADC signal wires should be placed far away from the other wires for minimum interference; and they should also be placed parallel to each other to have similar length for better signal integrity. However, since the pin density is too high of the HSMC connector we used, it is inevitable that the ADC wires are closed to the other wires. The ADC is placed on the other side of the PCB board for a better result.


\paragraph{Butterworth Filter}
To minimize the high frequency noise, a third-order low pass Butterworth filter is designed. With three poles, the attenuation is $-60 \sfrac{dB}{decade}$ on signals higher than the cut-off frequency. The filter topology used here is balanced ladder topology. Automatic design tool Elsie is used for designing the parameters of the RCI circuit. The cut-off frequency is $40MHz$.


\paragraph{Separate Power Supplies}
The buffer and ADC are separately powered from the other parts of the board. The $AD8139$’s power ranges from $5V$ to $12V$, and the ADC ranges from $2.7V$ to $3.6V$. Two low dropout regulators (LDP), $ADP3335$ and $ADP3333$ are used to offer $5V$ and $3.3V$ voltages respectively. The supply voltage of these two LDP ranges from $2.6V$ to $12V$. Their load currents are up to $500mA$ and $300mA$ respectively.


\subsection{B2 (Virtual design board)}

When started designing the B2 board for slave FPGA, the Altera Power Estimator is used for early power estimation calculations. Assume that an almost full usage of the FPGA, which means $90\%$ of all of logic blocks/cells, $90\%$ of multipliers and $90\%$ of memory elements, as well as $64$ I/O pins. The clock rate was assumed to be $100MHz$. In case of the toggle rates, two figures are assumed here. One set is $12.5\%$ on every net as a maximum toggle rate for the device while the other is $30\%$ which is a huge and unlikely to be realistic in the worst-case power consumption situation.

Ambient temperature was taken as $25^{\circ} C$ and no heat sink was assumed in the calculations, and no air flow (still air).

The power consumption result for $12.5\%$ toggle rate:
\begin{itemize}
 \item Logic: $0.235 W$
 \item RAM: $0.009 W$
 \item DSP: $0.032W$
 \item I/O: $0.023 W$
 \item PLL: $0.016 W$
 \item Clock: $0.135W$
 \item P\_static: $0.123W$
 \item Total: $\approx0.574 W$
\end{itemize}
For $30\%$ toggle rate the main change is the change in Logic power consumption, therefore consumption of Logic is $0.565 W$ and the in total is now $0.905 W$.

Translate these into power supply current requirements. For $12.5\%$ toggle rate:
\begin{itemize}
 \item Icc (int) ($1.2V$) $0.352A$
 \item Icc (A) ($2.5V$) $0.036A$
 \item Icc (d) ($1.2V$) $0.014A$
 \item Icc (IO) ($3.3V$) $0.013A$
\end{itemize}

For $30\%$ toggle rate main change is Icc (int) changes to $0.627A$.

The current consumption the main board provides is $1.5A$ in $3.3V$ power supply when $50\%$ usage of the FPGA, which is sufficient for both cases since only $20\%$ usage occupied in this project.


\subsubsection{Slave FPGA}

Slave FPGA is the core chip of the virtual design board. It can be used for programing designs when they are going to be tested. An Altera Cyclone III FPGA will be implemented as the slave FPGA.

Cyclone III ($EP3C25E144$) belongs to Cyclone III device family. With densities ranging from about $5,000$ to $200,000$ logic elements (LEs) and $0.5Mb$ to $8M$b of memory for less than $\sfrac{1}{4}V$ of static power consumption, Cyclone III devices makes it easier to meet the power budget \citep{Altera:2011:cyclone3handbook}.

The reason for choosing Cyclone III is their lowest power, high functionality with the lowest cost. 144 pins are enough for this design. I/O pins on the Cyclone III are grouped together into I/O banks, and each bank has a separate power bus. There are eight I/O banks, as shown in figure \ref{fig:b2_f1} \citep{Altera:2011:cyclone3handbook}. All single-ended I/O standards are supported in all banks except HSTL-12 Class II which is only supported in column banks. The same case can be found in all differential I/O standards.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure1}
 \caption{I/O banks in Cyclone III FPGA.}
 \label{fig:b2_f1}
\end{figure}

Each I/O banks of Cyclone III has a VREF bus to accommodate voltage-referenced I/O standards. Connect the VREF pin of each group to the appropriate voltage. In this design three voltage levels, which $VCCIO=3.3V$, $VCCINT= 1.2V$ and $VCCA=2.5V$, are necessary. Proper bypassing and decoupling technique for the power pins is very important for reliable design operation. In this case, additional decoupling capacitance is needed. The VCCINT, VCCIO and ground pins should add as many as $0.2\mu F$ power-supply decoupling capacitors as possible. So $0.01\mu F$ capacitor for VCCIO and $0.1\mu F$ for VCCINT seems to be appropriate. Note that all the capacitors should be place close enough to the power pins.

In regard of the Cyclone III configuration, the Cyclone II device uses SRAM cells to store configuration data. $EP3C25E144$ can only be configured in Fast Active serial (AS) mode.

Configuration data is loaded into Cyclone III at each DCLK cycle. As soon as the device receives all data, the device releases the open-drain CONF\_DONE pin, which is pulled high by an external 10- pull-up resistor. The CONF\_DONE pin transits low-to-high to indicate that configuration is complete and initialization of the device can begin. The CONF\_DONE pin must have a $10\Omega$ pull-up resistor for initialization.

Pulling the nCONFIG pin low can begin reconfiguration and this pin must be low for at least $500ns$. The Cyclone III device is reset when nCONFIG is pulled low. Meanwhile, the device will pulls nSTATUS and CONF\_DONE low and I/O pins are tri\_stated. When nCONFIG returns to high and nSTATUS is released, reconfiguration begins.

The clock source for initialization is either a $10MHz$ (typical) internal oscillator or an optional CLK pin. In this situation, an external oscillator (A $TXC-50MHz$ oscillator is going to be introduced later) will be implemented as the clock source. The required clock for initialization in Cyclone III is $3,185$ and the maximum CLUK frequency is $133MHz$.

The configuration mode is selected by driving the MSEL pins either low or high. The MSEL pins can be powered by VCCIO and GND. For AS mode, MSEL [1] should be pulled up by connecting to VCCIO. MSEL [0] and MESL [2] are pulled down by connecting to GND. The MESL pins have $9\Omega$ internal pull-down resistors that are always active.

The maximum active master frequency for Cyclone III is $30MHz$ typically and device only work with serial configuration devices that support up to $40MHz$.

In AS mode, Cyclone III reads the configuration data providing by serial configuration (A Spansion SPI Flash is going to be introduced later) via a serial interface. The serial configuration device controls the configuration interface.

There are four pins on the serial configuration devices:
\begin{itemize}
 \item Serial clock input (DCLK)
 \item serial data output (DATA)
 \item As data output (ASDI)
 \item Active-low chip select (nCS)
\end{itemize}

Connect these four pins to Cyclone III device pins, as shown in figure \ref{fig:b2_f2}

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure2}
 \caption{Connections between Serial Configuration Device and Cyclone III FPGA.}
 \label{fig:b2_f2}
\end{figure}

A $25\Omega$ series resistor must connect a between serial configuration device and the Cyclone III device at the near end of the serial configuration device for DATA [0] when configure the Cyclone III device in the AS mode. The $25\Omega$ resistor works to minimize the driver impedance mismatch with the board trace and reduce the overshoot seen at the Cyclone III device input pin DATA [0].

The maximum trace length between Cyclone III device and the serial configuration device, in another words, the DCLK, DATA [0], NCSO and ADSO pins, must be less than $10in$. In the B1 PCB designing, only $8mm$ is used.

Cyclone III device uses a $40MHz$ internal oscillator to generate DCLK to controls the entire configuration cycle and provide timing for the serial interface.

By driving the nCSO output pin low, which connect to nCS pin of the configuration device, the Cyclone III device enables the configuration device.  DCLK and DATA [1] pins are used to send operation commands and read address signals to the serial configuration device. The configuration device sends data on DATA pin which connects to the DATA [0] pin of the Cyclone III device. After all the configuration bits are received, Cyclone III releases the open-drain CONF\_DONE pin with a $10\Omega$ pull-up resistor. The CONF\_DONE pin must have an external $10\Omega$ resistor for the device to initialize.


\subsubsection{Serial Configuration Device}

Cyclone III FPGAs are programmable logic devices used for basic logic functions, chip-to-chip connectivity, signal processing, and embedded processing. They can be programmed and configured by a microprocessor, JTAG port, or directly bay a serial PROM or flash. Spansion SPI (Serial Peripheral Interface) flash $S25FL064K$ can configure the FPGA easily at power-up \citep{Spansion:2011:appnote}.

The three stages of the configuration cycle are power-on reset, configuration, and initialization. When the FPGA enters power-on rest (POR), it drives the nSTATUS signal low to indicate it is busy, drives the CONF\_DONE signal low to indicate the configuration has not been completed, and tri-states all I/O pins. All pins will be released after POR.

The DCLK generated by the FPGA device control the configuration data transferring. The CONF\_DONE pin will be released with pulling high by an external pull-up resistor after all configuration data is transferred to the FPGA. The FPGA enters user mode after internal initialization.

The SPI is a simple four-pin synchronous interface protocol which enables a master device and one or more slave devices to intercommunicate. Four signal wires are:
\begin{itemize}
 \item Master Out Slave In (MOSI) signal generated by the master (data to slave)
 \item Master In Slave Out (MISO) signal generated by the slave (data to master)
 \item Serial Clock (SCK) signal generated by the master to synchronize data transfers
 \item Slave Select (SS) signal generated by master to select individual slave devices (also known as Chip Select (CS) or Chip Enable (CE))
\end{itemize}


Figure \ref{fig:b2_f3} displays a simple block diagram of the connection between FPGA and SPI flash, as well as the HSMC header and JTAG programming the SPI flash from a host PC.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure3}
 \caption{AS interface.}
 \label{fig:b2_f3}
\end{figure}


Figure \ref{fig:b2_f4} displays the details of the connection between SPI flash and FPGA. According to the introduction of Cyclone III, we can acquire the whole routing of FPGA, SPI flash and the HSMC header (A Samtec ASP header will be introduced later).

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure4}
 \caption{The connection between SPI flash and FPGA in detail.}
 \label{fig:b2_f4}
\end{figure}

The TMS, TDI, TDO and TCK pins of Cyclone III device are used to operating in the IEEE Std. 1149.1 BST. The TDO pin is powered by VCCIO (3.3V). TDI and TMS are powered by VCCA (2.5V).

The header for JTAG and the header for SPI Flash In-system is use the same HSMC header with 172 pins which is quite enough for these two headers.




\subsubsection{External Oscillator}

As mentioned in the Cyclone III part, an external oscillator is needed as the clock source to provide certain frequency for the FPGA. A $50MHz$ oscillator of TXC will be implemented. The typical clock frequency for Cyclone III device is $30HMz$ and the maximum is $40MHz$. The TXC DEL04 oscillator is a sealed clock crystal oscillator unit with high precision characteristic covering up to wide frequency range ($1MHz$ to $170 MHz$), which is appropriate for the FPGA. The supply voltage range is $1.8V-5V$ \citep{TXC:osc_datasheet}.


\subsubsection{Voltage Regulator}

The B2 board needs at least three different voltage levels, as mentioned before, $VCCIO=3.3V$, $VCCINT= 1.2V$ and $VCCA=2.5V$. The external power source is provided by the main FPGA DE2-115 board at $3.3V$. Hence two voltage regulators are used to transfer $3.3V$ into $1.2V$ and $2.5V$.

\paragraph{1.2V Voltage Regulator \texorpdfstring{$LD1117$}{LD1117}}
The $LD111712$ is a low drop voltage regulator able to provide up to $800mA$ of output current, available in adjustable version (). The device is supplied in DPAK surface mount package optimize the thermal characteristics even offering a relevant space saving effect. A very common $10\Omega$ minimum capacitor is needed for stability \citep{STMicro:2012:LD1117xx}.

Figure \ref{fig:b2_f5} is the application circuit for $1.2V$ output.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure5}
 \caption{Application circuit for 1.2V output.}
 \label{fig:b2_f5}
\end{figure}



\paragraph{2.5V Voltage Regulator \texorpdfstring{$TPS78225$}{TPS78225}}
The $TPS78228$ is a low dropout linear voltage regulator designed by TI. The enable pin (EN) is compatible with standard CMOS logic while the low drop output is stable with any capacitor greater than 1. The device requires minimal board space for miniaturized packaging and potentially small output capacitor \citep{TI:2008:TPS782}.

The enable pin is active high and is compatible with standard and low-voltage CMOS levels. Therefore if the shutdown capacitor is not necessary, enable pin can connect to the $IN$ pin as shown on figure \ref{fig:b2_f6}.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure6}
 \caption{Connection between enable and IN pins.}
 \label{fig:b2_f6}
\end{figure}

Both current for voltage regulators are linear. They maintain when the toggle rate is changed. For example, $0.352A$ at $1.2V$ are still $0.352A$ at $3.3V$.


\subsubsection{HSMC Header}

The Altera High Speed Mezzanine Card (HSMC) specification defines the electrical and mechanical properties of the HSMC adapter interface for FPGA-based motherboards. The HSMC connector is based on the Samtec $0.5mm$ pitch, surface-mount QTH/QSH family of connectors \citep{Altera:2009:HSMCspec}. Two versions can are used in FPGA board. $ASP-122953-01$ Socket for the host boards and $ASP-122952-01$ Header for Mezzanine Cards (slave boards).

Figure \ref{fig:b2_f7} is the diagram for HSMC header. The clock-data-recovery differential signals in Bank 1 are the highest frequency signals. Signals between the HSMC connector and the host board FPGA device are intended to be D/C coupled. The JTAG, a system management bus (SMBus), and clock signals are also dedicated in Bank 1. In banks 2 and Bank 3, there are main CMOS/LVDS interface signals, including LVDS/COMS clocks, as well as both $12V$ and $3.3V$ power pins.

\begin{figure}
 \centering
 \includegraphics[width=0.3\textwidth]{figure7}
 \caption{HSMC header diagram.}
 \label{fig:b2_f7}
\end{figure}

The host board is any board with an FPGA connected to one or more HSMC interface. In this project it is DE2-115 developed board. The interconnect I/O pins available on the HSMC connector can have all possible I/O standard and logic features that can be supported by the host FPGA since FPGAs are configurable devices. However basically they are limited by the wire types on the board.


The HSMC connectors provided the interface between host and slave boards. The ``header'' part ($ASP-122952-01$) on slave board plugs into the ``socket'' part on the host board. The host board provides $+12V$ DC and $+3.3V$ DC power to the slave board via the HSMC connector. In addition to power and clock signals, the host board provides access to JTAG, high speed serial I/O, and single-ended or differential I/O via the HSMC connector.

The HSMC connector has a total of $172$ pins, including $121$ signal pins ($120$ signal pins + $1$ PSNTn pin), $39$ power pins, and $12$ ground pins. The ground pins are much larger than the power pins and are located between the two rows of signal and power pins. Figure \ref{fig:b2_f8} is the modules for HSMC connectors.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{figure8}
 \caption{HSMC connectors modules.}
 \label{fig:b2_f8}
\end{figure}

The $ASP-122952-01$ header provides $160$ total pins and $12$ ground plane connection pins down the center. Bank 1 has $40$ pins with every third pin removed. Bank 2 and 3 have $60$ pins each as no pins are removed. Host boards provide transceivers to Bank 1 which is not used in this project. Single-ended signals are provided to Bank 2 and 3. Typically, the single-ended signals are capable of differential signalling such as LVDS.

The JTAG signals are intended to connect to dedicated JTAG pins on the host FPGA and be part of the JTAG chain. The JTAG signals TCK, TMS and TDI are intended to be output from host board while JTAG TDO should be the input to host board as figure \ref{fig:b2_f4} before.

Tables \ref{tab:b1_hsmc_pinout} and \ref{tab:b2_hsmc_pinout} in the appendix show the pin-outs for the HSMC header on B1 and B2 boards, respectively.


\section{Chip Tester (Verilog Module)}


\subsection{Reconfigurable Clock Domain}
The design under test (DUT) is isolated from the clock domain of the main board, since various designs may operate on different clock frequencies. In order to realize this, we used a dynamically reconfigurable Phase Lock Loop (PLL) to realize the separately reconfigurable clock domain without influencing the clock of the main board.

\subsection{Synchronizing with FIFOs}
The data integrity between the two clock domains are ensured by Altera IP core Dual-Clock First-In-First-Out (DCFIFO) megafunction, which is widely used for data buffering in asynchronous clock domains. In the DCFIFO, the read and write signals are synchronized to the rdclk and wrclk clocks respectively.

When the $wrfull$ port is low, assert wrreq to request for a write operation. Input data synchronized by $wrclk$, is hold in the stack when the $wrreq$ is high. When the $rdempty$ port is high, insert $rdreq$ for a reading request. Then the data will be exhibited from the $q$ port. $aclr$ is used for clearing the data stored in the DCFIFO. The figures bellow shows the timing and behaviour of the write and read process.



\subsection{Test Controller}

\subsubsection{mem if}
``mem\_if'' arbitrates the access to the Avalon memory between ``stim'' and ``check'' module. Altera Avalon is the standard interface of Altera devices, allowing the design to access system resources (e.g. SRAM) on the DE2 board. The address-based read/write Interface Avalon Memory Mapped Interface (Avalon-MM) is used here. The read require from ``stim'' is prior to the write require of memory from ``check''. Since the tester can run massive amount of tests in a very short time, the address-based Avalon-MM can ensure the test vectors and result vectors correspond to each other in the memory.

\subsubsection{stim}
The ``stim'' module reads test vector, command information, PLL reconfiguration data from the memory, and then sends the information to ``check'' module and ``dut\_if'' module. The data to ``check'' is through ``cfifo'' (don’t-care bits, result vector, address) and ``sc\_data'' (bit mask), while to ``dut\_if'' is through ``sfifo'' (for test vectors) and ``dififo'' (for request, command and trigger/clock pin mask). The ``stim'' module is also responsible for sending the target select data to the $4-16$ decoder for powering up single design and sending counters configuration data to the PLL reconfiguration module and controlling the reconfiguration process.

The bit mask is used to eliminate the pins that are not included in the functional outputs (part of the physical chip; not part of the design, however), whose value does not influence the result. In some specific conditions, some pins are part of the design; however, their status is not part of the result, such as a ``busy'' or a flag signal. Such pins are covered by the ``don't-care bits''.


The request types are read in the READ\_META state. Depending on different request types, the ``stim'' responds to the according tasks as follows:

\begin{itemize}
 \item setup bit mask (SETUP\_BITMASK). In this task the bit mask and relative command type are sent to the ``check'' module through a register output, bypassing the FIFO between ``stim'' and ``check''.

 \item read test vector (READ\_TV, WR\_FIFPOS). The test vecotor is firstly read from memory in serial, then sent to the ``dut\_if'' for the input of the design and to the ``check'' for reference through FIFOs in this task.

 \item send command/data to dut\_if (SEND\_DICMD, WR\_DIFIFO). This task is used for assigning clock pins to the DUT inputs and setting up trigger pins to the DUT output pins. These are explained in the dut\_if section.

 \item switch design target (SWITCH\_TARGET, SWITCH\_VDD). As introduced previously, there are 16 designs at most on a single chip under test. Only one can be selected by powering up its exclusive VDD pin. In this task, a $4-bit$ signal indicating which design is selected is sent to the testing board. On the B1 board, a $4-16$ decoder will decode the information and integrated switches array will turn on only one design.

 \item start reconfiguring the dynamic PLL (START\_REPLL, PLL\_RECONFIG, PLL\_WAIT). In this task, the parameters for the PLL counters are read from the memory first. Then in the PLL\_RECONFIG state a trigger will be sent to the PLL\_INTERFACE module with those parameters to start the configuration process. Then the PLL\_WAIT state will halt the ``stim'' until the new PLL output frequency is stable.
\end{itemize}

After each task is done, the ``stim'' returns to the IDLE state, waiting for the next request. When a complete test is finished, the ``stim'' goes to an END state and resets itself to the start IDLE state.

The state transition chart is as shown in figure \ref{fig:hw_state_trans_chart}.

\begin{figure}
 \centering
 \includegraphics[width=0.9\textwidth]{hw_state_trans_chart}
 \caption{State Transition Chart.}
 \label{fig:hw_state_trans_chart}
\end{figure}

\begin{table}[ht]
\centering
\begin{tabular}{|l|p{0.5\textwidth}|}
\hline
State & Behaviour \\
\hline
IDLE & reset variables (words\_stored, read\_requested) \\
READ\_META & read metadata from memory \\
READ\_TV & read test vector from memory \\
SWITCH\_TARGET & read target information from memory and store in new\_target\_sel \\
SWITCH\_VDD & change target power based on the target\_sel data (updated by new\_target\_sel) \\
WR\_FIFOS & send write request to FIFOs by sfifo\_wrreq, cfifo\_wrreq \\
SETUP\_BITMASK & read bitmask from memory, send sc\_cmd, sc\_data to check module \\
SEND\_DICMD & read command data for DUT\_if \\
WR\_DIFIFO & send write request to DUT\_if through dififo \\
START\_REPLL & read data for PLL reconfiguration from memory \\
PLL\_RECONFIG & send trigger to PLL to start the reconfiguration process \\
PLL\_WAIT & put the stim waiting until the PLL clock is stable \\
END & when all the FIFOs are empty, send done signal to upper level \\
\hline
\end{tabular}
\caption{States Behaviour Table.}
\label{tab:states_behaviour}
\end{table}

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|p{0.45\textwidth}|}
\hline
Source State & Destination State & Condition \\
\hline
END & IDLE & sfifo\_wrempty \&\& cfifo\_wrempty \&\& enable \\
IDLE & READ\_META & $\sim$sfifo\_wrfull \&\& $\sim$cfifo\_wrfull \&\& $\sim$mem\_waitrequest \\
READ\_META & END & words\_stored \&\& req\_type==REQ\_END \\
READ\_META & IDLE & words\_stored \&\& req\_type==REQ\_PLLRECONFIG \\
READ\_META & READ\_META &  \\
READ\_META & SWITCH\_TARGET & words\_stored \&\& req\_type==REQ\_SWITCH\_TARGET \\
READ\_META & READ\_TV & words\_stored \&\& req\_type==REQ\_TEST\_VECTOR \\
READ\_META & SEND\_DICMD & words\_stored \&\& req\_type==REQ\_SEND\_DICMD \\
READ\_META & SETUP\_BITMASK & words\_stored \&\& req\_type==REQ\_SETUP\_BITMASK \\
READ\_TV & WR\_FIFOS & words\_stored == tv\_len \\
SEND\_DICMD & WR\_DIFIFO & words\_stored == 3 \&\& $\sim$dififo\_wrfull \&\& sfifo\_wrempty \&\& cfifo\_wrempty \\
SETUP\_BITMASK & IDLE & words\_stored == 3 \\
START\_REPLL & PLL\_RECONFIG & words\_stored == 3 \&\& pll\_locked \\
PLL\_RECONFIG & PLL\_WAIT &  \\
PLL\_WAIT & IDLE & pll\_stable \\
SWITCH\_TARGET & SWITCH\_VDD & sfifo\_wrempty \&\& cfifo\_wrempty \\
SWITCH\_VDD & IDLE & waitcnt == 0 \\
WR\_DIFIFO & IDLE &  \\
WR\_FIFOS & IDLE &  \\
\hline
\end{tabular}
\caption{Main States Transitions Table.}
\label{tab:states_transitions}
\end{table}

\subsection{check}

The ``check'' module compares the test result from ``dut\_if'' (through ``rfifo'') and the reference result from ``stim'' (through ``cfifo'') and decides whether the test is passed or failed. The information is then stored in metadata. The test result vector is also written into the memory by this module. As previously introduced, the test result vector and the reference result vector are firstly processed by the bitmask and don't-care bits before comparing.





\subsubsection{dut if}

The ``dut\_if'' module is the interface between the VLSI system and the design under test (DUT). It uses the data from ``stim'' to generate the test vector and send it to the DUT. After certain conditions are satisfied, the result is valid from the DUT, which is then sent to the check through ``rfifo''.

The test vector is merged with clock pins before being sent to the DUT. The clock is from the reconfigurable clock domain. This process is, however, not necessary in every test. It depends on whether the design contains a clock input and whether the user defines it in the input data. A clock gating is also done in this part for optimizing power consumption.
In deciding whether the result is valid, the ``dut\_if'' supports two modes:

\begin{enumerate}
 \item With a predefined clock cycle number (in metadata), the dut\_if sets up a counter to wait until the clock cycles are reached. Then the result is considered valid. If the clock cycle number is 0, the result is taken within the same clock cycle, which corresponds to a combinational logic circuit. Otherwise, the DUT should be a sequential design with a fixed clock cycle to output the valid result.

 \item With a set of pins which is defined as the trigger (e.g. a ``done'' or ``ready'' signal). The result is considered valid when the triggers change. This corresponds to asynchronous handshake behaviour. This is implemented by the trigger mask.
\end{enumerate}

Those different modes of operation are set by the user in the metadata, depending on specific designs.

The speed of the ``dut\_if'' is boosted by pipelining technique, including fetch, execute and writeback stages. The fetch stage checks whether the ``sfifo'' is empty and decide if the process should go to the next stage. The execute stage handles the testing process from sending the test vector to receiving the result vector. After a execute stage, the writeback stage is in place to write the data (result vector, metadata) to the memory. The pipelining enables the ``dut\_if'' to process the different stages of three tasks at the same time.

\subsubsection{PLL INTERFACE}

The reconfigurable clock domain uses the Altera IP cores ALTPLL and ALTPLL\_RECONFIG to realize the dynamically reconfigurable clock. The ALTPLL generates stable clock. The input clock frequency is divided and multiplied by the internal counters, resulting in a variable output frequency. The parameters are initialized by a scan chain. Reinitializing the PLL with a new scan chain is possible and can change the output frequency with different parameters. However the scan chain contains too much information that is not expected to change during our process (counters that are not changed, current, phase information, etc.). ALTPLL\_RECONFIG module can change specific parameters based on a complete scan chain and reinitialize the ALTPLL.

The ALTPLL\_RECONFIG module requires input to be in serial and specific timing requirements. The process is coordinated by REPLL\_CONTROL, responding to an input trigger, transferring the parallel input into serial, and offering a stable signal when the reconfiguration is done. All these modules are enveloped in PLL\_INTERFACE.

The counters used here are M (feedback multiplier counter), N (pre-divider counter) and C (post-divider counter) counters. The output frequency = input frequency * M/(N*C). Currently the established minimum output frequency is $0.005\times$ the input clock frequency, which is $100MHz$ of the DE2 board by default. The maximum can reach $10\times$ the input clock, and theoretically can be increased. However, further testing is not done since $1GHz$ is already big enough for our hardware. Should further testing require lower frequency ($<500KHz$ ), another cascaded PLL\_INTERFACE module could be implemented as a possible solution.

The formats of the data for different requests used in this part of the design are listed below.

% Test Vector:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{test_vector}
 \caption{Test Vector.}
 \label{fig:test_vector}
\end{figure}






% Change target:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{change_target}
 \caption{Change Target.}
 \label{fig:change_target}
\end{figure}




% Change bitmask:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{change_bitmask}
 \caption{Change Bitmask.}
 \label{fig:change_bitmask}
\end{figure}



% Send dicmd:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{send_dicmd}
 \caption{Send dicmd.}
 \label{fig:send_dicmd}
\end{figure}



% PLL reconfiguration:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{pll_reconfig}
 \caption{PLL Reconfiguration.}
 \label{fig:pll_reconfig}
\end{figure}


% Mem end:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{mem_end}
 \caption{Mem End.}
 \label{fig:mem_end}
\end{figure}



% Metadata:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{metadata}
 \caption{Metadata.}
 \label{fig:metadata}
\end{figure}



% Metadata 2:

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.9\textwidth]{metadata_2}
 \caption{Metadata 2.}
 \label{fig:metadata_2}
\end{figure}


\section{SRAM Arbiter (sram\_arb\_sync.v)}

The SRAM arbiter allocates acces of the SRAM to the modules connected to the Avalon MM interface that require read/write access to the SRAM, namely the ADC, the SOPC core and the TestRunner \hl{right?}.

Depending on a master selection signal, the arbiter selects one of the aforementioned modules and provides it with access to the SRAM. The arbiter also interfaces the read, write and enable signals between the two sides (SRAM and modules connected to the Avalon MM).

Upon reset, the arbiter nulls all registers and disconnects all wires. Otherwise, the arbiter connects the selected module to the SRAM.